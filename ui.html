<style>
  @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap');

  :root {
    /* Monochrome neutral palette */
    --background: 0 0% 100%;
    --foreground: 0 0% 9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --success: 0 0% 9%;
    --success-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 9%;
    --radius: 0.5rem;
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: 'Manrope', -apple-system, BlinkMacSystemFont, sans-serif;
    padding: 0.875rem 1rem 1rem;
    margin: 0;
    background: hsl(var(--background));
    color: hsl(var(--foreground));
    font-size: 14px;
    line-height: 1.5;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  h2 {
    margin: 0 0 0.25rem 0;
    font-size: 15px;
    font-weight: 800;
    letter-spacing: 0.3em;
    color: hsl(var(--foreground));
    text-transform: uppercase;
  }

  .description {
    margin: 0 0 0.75rem 0;
    font-size: 11px;
    color: hsl(var(--muted-foreground));
    line-height: 1.4;
  }

  /* Status Alert Styles */
  .status {
    margin: 0 0 0.875rem 0;
    padding: 0.625rem 0.875rem;
    border-radius: var(--radius);
    font-size: 0.8125rem;
    min-height: 2.25rem;
    display: flex;
    align-items: center;
    border: 1px solid hsl(var(--border));
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
  }

  .status.error {
    background: hsl(var(--destructive) / 0.1);
    color: hsl(var(--destructive));
    border-color: hsl(var(--destructive) / 0.3);
  }

  .status.success {
    background: hsl(var(--success) / 0.1);
    color: hsl(var(--success));
    border-color: hsl(var(--success) / 0.3);
  }

  /* Button Styles */
  button {
    width: 100%;
    padding: 0.5rem 1rem;
    margin-top: 0;
    margin-bottom: 0.375rem;
    border: 1px solid transparent;
    border-radius: var(--radius);
    font-family: inherit;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 150ms ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    height: 2.25rem;
  }

  button:last-child {
    margin-bottom: 0;
  }

  button:focus-visible {
    outline: none;
    ring: 2px;
    ring-color: hsl(var(--ring));
    ring-offset: 2px;
  }

  #export {
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  }

  #export:hover:not(:disabled) {
    background: hsl(var(--primary) / 0.9);
  }

  #export:active:not(:disabled) {
    background: hsl(var(--primary) / 0.95);
  }

  #export:disabled {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    cursor: not-allowed;
    opacity: 0.6;
  }

  #cancel {
    background: hsl(var(--background));
    color: hsl(var(--foreground));
    border: 1px solid hsl(var(--border));
  }

  #cancel:hover {
    background: hsl(var(--accent));
    color: hsl(var(--accent-foreground));
  }

  #cancel:active {
    background: hsl(var(--accent) / 0.8);
  }

  /* AI Rename Button Styles */
  #ai-rename {
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    margin-bottom: 0.375rem;
  }

  #ai-rename:hover:not(:disabled) {
    background: hsl(var(--primary) / 0.9);
  }

  #ai-rename:active:not(:disabled) {
    background: hsl(var(--primary) / 0.95);
  }

  #ai-rename:disabled {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    cursor: not-allowed;
    opacity: 0.6;
  }

  /* Section Separator */
  .section-separator {
    margin: 1rem 0 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px solid hsl(var(--border));
  }

  .section-label {
    font-size: 0.6875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: hsl(var(--muted-foreground));
    margin-bottom: 0.5rem;
  }

  /* Secondary/Utility Button Styles (lower priority) */
  .utility-buttons {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
  }

  .utility-button {
    flex: 1;
    background: hsl(var(--background));
    color: hsl(var(--muted-foreground));
    border: 1px solid hsl(var(--border));
    font-size: 0.75rem;
    padding: 0.5rem 0.625rem;
    height: 2rem;
    font-weight: 500;
  }

  .utility-button:hover:not(:disabled) {
    background: hsl(var(--accent));
    color: hsl(var(--accent-foreground));
    border-color: hsl(var(--foreground) / 0.2);
  }

  .utility-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .utility-button .btn-icon {
    width: 0.875rem;
    height: 0.875rem;
    margin-right: 0.375rem;
  }

  /* Generate Edits Button Styles */
  #generate-edits {
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    margin-bottom: 0.375rem;
  }

  #generate-edits:hover:not(:disabled) {
    background: hsl(var(--primary) / 0.9);
  }

  #generate-edits:active:not(:disabled) {
    background: hsl(var(--primary) / 0.95);
  }

  #generate-edits:disabled {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    cursor: not-allowed;
    opacity: 0.6;
  }

  /* Progress Status */
  .progress-status {
    margin: 0 0 0.875rem 0;
    padding: 0.625rem 0.875rem;
    border-radius: var(--radius);
    font-size: 0.75rem;
    border: 1px solid hsl(var(--border));
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    display: none;
  }

  .progress-status.visible {
    display: block;
  }

  /* Frame Selection Tag */
  .frame-tag {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.375rem 0.75rem;
    margin-bottom: 0.75rem;
    background: hsl(var(--muted));
    border: 1px solid hsl(var(--border));
    border-radius: calc(var(--radius) - 2px);
    font-size: 0.8125rem;
    font-weight: 500;
    color: hsl(var(--muted-foreground));
    transition: all 200ms ease;
  }

  .frame-tag.has-selection {
    background: hsl(var(--success) / 0.1);
    border-color: hsl(var(--success) / 0.3);
    color: hsl(var(--success));
  }

  .frame-tag-icon {
    width: 1rem;
    height: 1rem;
    color: currentColor;
  }

  /* Button Icon Styles */
  .btn-icon {
    display: inline-block;
    margin-right: 0.5rem;
    width: 1rem;
    height: 1rem;
  }

  .spinner {
    animation: spin 1s linear infinite;
    width: 1rem;
    height: 1rem;
  }

  @keyframes spin {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }

  .hidden {
    display: none;
  }

  /* Checkbox Styles */
  .checkbox-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
    padding: 0.5rem 0.75rem;
    border-radius: var(--radius);
    background: hsl(var(--muted) / 0.5);
    border: 1px solid hsl(var(--border));
    cursor: pointer;
    transition: all 150ms ease;
  }

  .checkbox-container:hover {
    background: hsl(var(--muted));
  }

  .checkbox-container input[type="checkbox"] {
    width: 1rem;
    height: 1rem;
    margin: 0;
    accent-color: hsl(30 80% 50%);
    cursor: pointer;
  }

  .checkbox-container label {
    font-size: 0.8125rem;
    color: hsl(var(--foreground));
    cursor: pointer;
    user-select: none;
    flex: 1;
  }

  .checkbox-container .checkbox-hint {
    font-size: 0.6875rem;
    color: hsl(var(--muted-foreground));
  }

  /* Select/Dropdown Styles */
  .select-container {
    margin-bottom: 0.75rem;
  }

  .select-container label {
    display: block;
    font-size: 0.75rem;
    color: hsl(var(--muted-foreground));
    margin-bottom: 0.375rem;
    font-weight: 500;
  }

  select {
    width: 100%;
    padding: 0.5rem 0.75rem;
    font-family: inherit;
    font-size: 0.8125rem;
    color: hsl(var(--foreground));
    background: hsl(var(--background));
    border: 1px solid hsl(var(--border));
    border-radius: var(--radius);
    cursor: pointer;
    transition: all 150ms ease;
  }

  select:hover {
    border-color: hsl(var(--foreground) / 0.3);
  }

  select:focus {
    outline: none;
    border-color: hsl(var(--foreground));
    box-shadow: 0 0 0 2px hsl(var(--foreground) / 0.1);
  }

  select:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Input Field Styles */
  .input-container {
    margin: 0 0 0.75rem 0;
  }

  .input-container label {
    display: block;
    margin-bottom: 0.5rem;
    font-size: 0.8125rem;
    font-weight: 500;
    color: hsl(var(--foreground));
  }

  input[type="email"],
  input[type="text"] {
    width: 100%;
    padding: 0.5rem 0.75rem;
    font-family: inherit;
    font-size: 0.8125rem;
    color: hsl(var(--foreground));
    background: hsl(var(--background));
    border: 1px solid hsl(var(--border));
    border-radius: var(--radius);
    transition: all 150ms ease;
  }

  input[type="email"]:hover,
  input[type="text"]:hover {
    border-color: hsl(var(--foreground) / 0.3);
  }

  input[type="email"]:focus,
  input[type="text"]:focus {
    outline: none;
    border-color: hsl(var(--foreground));
    box-shadow: 0 0 0 2px hsl(var(--foreground) / 0.1);
  }

  input[type="email"]::placeholder,
  input[type="text"]::placeholder {
    color: hsl(var(--muted-foreground));
  }
</style>

<h2>Exporter</h2>
<p class="description">Export your designs for taggr submissions</p>

<div class="progress-status" id="progress-status"></div>

<div class="frame-tag" id="frame-tag">
  <svg class="frame-tag-icon" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <rect x="3" y="3" width="10" height="10" rx="1" />
  </svg>
  <span id="frame-count">No frames selected</span>
</div>

<div class="input-container">
  <label for="user-email">Your Email</label>
  <input type="email" id="user-email" placeholder="your.email@example.com" />
</div>

<div class="section-separator">
  <div class="section-label">Utility Tools</div>
</div>

<div class="utility-buttons">
  <button id="break-groups" class="utility-button">
    <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
      <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
    </svg>
    <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
    </svg>
    <span class="btn-text">Break Groups</span>
  </button>
  <button id="rasterize" class="utility-button">
    <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
      <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
    </svg>
    <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
    </svg>
    <span class="btn-text">Rasterize (4x)</span>
  </button>
</div>

<div class="select-container">
  <label for="prompt-selector">AI Prompt Style</label>
  <select id="prompt-selector">
    <option value="">Loading prompts...</option>
  </select>
</div>

<div class="checkbox-container" onclick="document.getElementById('generate-images').click(); event.stopPropagation();">
  <input type="checkbox" id="generate-images" onclick="event.stopPropagation();">
  <label for="generate-images">Generate AI Images</label>
</div>

<button id="ai-rename">
  <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
    <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
  </svg>
  <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
  </svg>
  <span class="btn-text">AI Rename Layers</span>
</button>
<button id="generate-edits">
  <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
    <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
  </svg>
  <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
  </svg>
  <span class="btn-text">Generate Edits (5 variants)</span>
</button>
<button id="export">
  <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
    <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
  </svg>
  <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
  </svg>
  <span class="btn-text">Export Only</span>
</button>
<button id="cancel">Cancel</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>

  // ============================================
  // DOM Elements
  // ============================================
  const exportBtn = document.getElementById('export');
  const aiRenameBtn = document.getElementById('ai-rename');
  const generateEditsBtn = document.getElementById('generate-edits');
  const breakGroupsBtn = document.getElementById('break-groups');
  const rasterizeBtn = document.getElementById('rasterize');
  const frameCountEl = document.getElementById('frame-count');
  const frameTagEl = document.getElementById('frame-tag');
  const progressStatus = document.getElementById('progress-status');
  const promptSelector = document.getElementById('prompt-selector');
  const userEmailInput = document.getElementById('user-email');

  // Backend server URL
  // IMPORTANT: Update this to your Railway URL after deployment!
  // Format: https://your-app-name.up.railway.app
  const BACKEND_URL = 'https://asli-designer-production.up.railway.app'; // Railway production URL
  console.log('[UI] Backend URL:', BACKEND_URL);

  // Store user email (from input field)
  // Note: localStorage is disabled in Figma plugins (data: URLs)
  let currentUserEmail = '';

  // Update email when user types
  userEmailInput.addEventListener('input', (e) => {
    currentUserEmail = e.target.value.trim();
    console.log('[UI] Email updated:', currentUserEmail || '(empty)');
  });

  // Store selected prompt file
  let selectedPromptFile = 'default.txt';

  // Store multiple frame exports (for single ZIP with folders)
  let frameExportData = [];

  // Helper to create filename from layer name (matching code.ts logic)
  function createFilename(name, id, ext = 'png') {
    // Sanitize the layer name: remove/replace invalid filename characters
    const safeName = name
      .replace(/[<>:"/\\|?*]/g, '_')  // Replace invalid filename chars
      .replace(/\s+/g, '_')            // Replace spaces with underscores
      .replace(/_+/g, '_')             // Collapse multiple underscores
      .replace(/^_|_$/g, '')           // Trim leading/trailing underscores
      .substring(0, 100);              // Limit length

    // Use sanitized name, fallback to ID if name is empty
    const baseName = safeName || id.replace(/:/g, '_');
    return `${baseName}.${ext}`;
  }

  // ============================================
  // Button State Management
  // ============================================
  function setButtonState(button, state, text) {
    const btnText = button.querySelector('.btn-text');
    const spinnerIcon = button.querySelector('.spinner');
    const checkIcon = button.querySelector('.check-icon');

    let defaultText = 'Export Only';
    if (button.id === 'ai-rename') {
      defaultText = 'AI Rename Layers';
    } else if (button.id === 'generate-edits') {
      defaultText = 'Generate Edits (5 variants)';
    } else if (button.id === 'break-groups') {
      defaultText = 'Break Groups';
    } else if (button.id === 'rasterize') {
      defaultText = 'Rasterize (4x)';
    }

    switch (state) {
      case 'loading':
        button.disabled = true;
        btnText.textContent = text || 'Processing...';
        spinnerIcon.classList.remove('hidden');
        checkIcon.classList.add('hidden');
        break;
      case 'success':
        button.disabled = false;
        btnText.textContent = defaultText;
        spinnerIcon.classList.add('hidden');
        checkIcon.classList.remove('hidden');
        setTimeout(() => setButtonState(button, 'default'), 2000);
        break;
      case 'default':
      default:
        button.disabled = false;
        btnText.textContent = defaultText;
        spinnerIcon.classList.add('hidden');
        checkIcon.classList.add('hidden');
        break;
    }
  }

  function showProgress(message) {
    progressStatus.textContent = message;
    progressStatus.classList.add('visible');
  }

  function hideProgress() {
    progressStatus.classList.remove('visible');
  }

  // ============================================
  // Backend API Calls
  // ============================================
  async function callRenamingAPI(layers) {
    const layerCount = layers.filter(l => l.imageData).length;
    const batchCount = Math.ceil(layerCount / 10); // Backend processes 10 at a time

    console.log(`[API] ðŸ“¤ Sending ${layerCount} layers to AI for renaming (will be processed in ${batchCount} batch${batchCount > 1 ? 'es' : ''} of 10)`);
    const startTime = Date.now();

    const response = await fetch(`${BACKEND_URL}/api/rename-layers`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userEmail: currentUserEmail, // Add user email
        layers: layers
          .filter(l => l.imageData) // Only send layers with image data
          .map(l => ({
            id: l.id,
            imageBase64: l.imageData,
            currentName: l.name,
            type: l.type
          }))
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.message || `Server error: ${response.statusText}`);
    }

    const result = await response.json();
    const duration = Date.now() - startTime;
    console.log(`[API] âœ… Received ${result.layers.length} renamed layers (took ${(duration / 1000).toFixed(1)}s)`);

    return result;
  }

  async function callGenerateEditsAPI(frameName, frameWidth, frameHeight, layers, frameImageBase64, generateImages = false) {
    console.log(`[API] ðŸŽ¨ Generating 5 design variants for "${frameName}" (${frameWidth}Ã—${frameHeight}, ${layers.length} layers)`);
    console.log(`[API] â³ AI is thinking... this may take 10-30 seconds`);
    const startTime = Date.now();

    const response = await fetch(`${BACKEND_URL}/api/generate-edits`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userEmail: currentUserEmail, // Add user email
        frameName,
        frameWidth,
        frameHeight,
        frameImageBase64,  // Include frame image for AI vision analysis
        generateImages,    // Whether to generate AI images for image layers
        promptFile: selectedPromptFile, // User-selected prompt style
        layers: layers.map(l => ({
          name: l.name,
          type: l.type,
          x: l.x,
          y: l.y,
          width: l.width,
          height: l.height,
          fills: l.fills,
          strokes: l.strokes,
          opacity: l.opacity,
          text: l.text,
          fontSize: l.fontSize,
          cornerRadius: l.cornerRadius,
          hasImageFill: l.hasImageFill  // Pass through image fill info
        }))
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `Server error: ${response.statusText}`);
    }

    const result = await response.json();
    const duration = Date.now() - startTime;
    console.log(`[API] âœ… Generated ${result.variants.length} variants for "${frameName}" (took ${(duration / 1000).toFixed(1)}s)`);

    return result;
  }

  async function uploadFrameToS3(frameName, zipBlob, variantCount, userEmail) {
    try {
      showProgress(`Uploading ${frameName}.zip to S3...`);
      console.log(`[UI] Starting S3 upload for ${frameName}.zip (${Math.round(zipBlob.size / 1024)}KB)`);

      // Convert blob to base64 using FileReader (more efficient for large files)
      const base64 = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          // Remove the "data:application/zip;base64," prefix
          const base64String = reader.result.split(',')[1];
          resolve(base64String);
        };
        reader.onerror = reject;
        reader.readAsDataURL(zipBlob);
      });

      const response = await fetch(`${BACKEND_URL}/api/upload-to-s3`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          frameName,
          zipData: base64,
          userEmail,
          variantCount,
          fileSizeBytes: zipBlob.size
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `S3 upload failed: ${response.statusText}`);
      }

      const result = await response.json();
      console.log(`[UI] âœ“ Uploaded ${frameName}.zip to S3: ${result.s3Url}`);
      showProgress(`âœ“ Uploaded ${frameName}.zip to S3 (${Math.round(result.fileSizeBytes / 1024)}KB)`);

      return result;
    } catch (error) {
      console.error(`[UI] S3 upload failed for ${frameName}:`, error);
      showProgress(`âš ï¸ S3 upload failed for ${frameName}: ${error.message}`);
      // Don't throw - allow export to continue even if S3 upload fails
    }
  }

  // ============================================
  // Fetch and Populate Prompts
  // ============================================
  async function loadPrompts() {
    try {
      console.log('[UI] Fetching available prompts...');
      const response = await fetch(`${BACKEND_URL}/api/prompts`);

      if (!response.ok) {
        throw new Error('Failed to fetch prompts');
      }

      const data = await response.json();
      const prompts = data.prompts || [];

      console.log(`[UI] Loaded ${prompts.length} prompts:`, prompts);

      // Clear existing options
      promptSelector.innerHTML = '';

      // Populate dropdown
      prompts.forEach(prompt => {
        const option = document.createElement('option');
        option.value = prompt.filename;
        option.textContent = prompt.name;
        if (prompt.isDefault) {
          option.selected = true;
          selectedPromptFile = prompt.filename;
        }
        promptSelector.appendChild(option);
      });

      console.log(`[UI] Selected prompt: ${selectedPromptFile}`);
    } catch (error) {
      console.error('[UI] Error loading prompts:', error);
      // Fallback to default
      promptSelector.innerHTML = '<option value="default.txt">Default</option>';
      selectedPromptFile = 'default.txt';
    }
  }

  // Update selected prompt when user changes selection
  promptSelector.addEventListener('change', (e) => {
    selectedPromptFile = e.target.value;
    console.log(`[UI] Prompt changed to: ${selectedPromptFile}`);
  });

  // Load prompts on page load
  loadPrompts();

  // ============================================
  // Break Groups Apart Flow
  // ============================================
  breakGroupsBtn.onclick = () => {
    console.log('Break Groups button clicked');
    try {
      setButtonState(breakGroupsBtn, 'loading', 'Breaking groups...');
      showProgress('Breaking groups apart...');

      parent.postMessage({
        pluginMessage: { type: 'break-groups' }
      }, '*');
    } catch (e) {
      console.error('Break Groups error:', e);
      setButtonState(breakGroupsBtn, 'default');
      hideProgress();
      alert('Error: ' + e.message);
    }
  };

  // ============================================
  // Rasterize Selection Flow
  // ============================================
  rasterizeBtn.onclick = () => {
    console.log('Rasterize button clicked');
    try {
      setButtonState(rasterizeBtn, 'loading', 'Rasterizing...');
      showProgress('Converting to raster images at 4x resolution...');

      parent.postMessage({
        pluginMessage: { type: 'rasterize-selection' }
      }, '*');
    } catch (e) {
      console.error('Rasterize error:', e);
      setButtonState(rasterizeBtn, 'default');
      hideProgress();
      alert('Error: ' + e.message);
    }
  };

  // ============================================
  // AI Rename Flow (decoupled from export)
  // ============================================
  aiRenameBtn.onclick = async () => {
    console.log('AI Rename button clicked');
    try {
      setButtonState(aiRenameBtn, 'loading', 'Preparing...');
      showProgress('Starting AI rename process...');

      // Request layer images for renaming
      parent.postMessage({
        pluginMessage: { type: 'export-for-renaming' }
      }, '*');
    } catch (e) {
      console.error('AI Rename error:', e);
      setButtonState(aiRenameBtn, 'default');
      hideProgress();
      alert('Error: ' + e.message);
    }
  };

  // ============================================
  // Generate Edits Flow
  // ============================================
  generateEditsBtn.onclick = async () => {
    console.log('Generate Edits button clicked');
    try {
      setButtonState(generateEditsBtn, 'loading', 'Preparing...');
      showProgress('Checking selection...');

      // Request frame count check first
      parent.postMessage({
        pluginMessage: { type: 'check-frames-for-edits' }
      }, '*');
    } catch (e) {
      console.error('Generate Edits error:', e);
      setButtonState(generateEditsBtn, 'default');
      hideProgress();
      alert('Error: ' + e.message);
    }
  };

  // ============================================
  // Regular Export Flow
  // ============================================
  exportBtn.onclick = () => {
    console.log('Export button clicked');
    try {
      // Clear any previous export data
      frameExportData = [];

      setButtonState(exportBtn, 'loading', 'Exporting...');
      showProgress('Exporting frame...');

      const format = 'png';
      const scale = 2; // Reduced from 4x to 2x for faster exports (still high quality)

      parent.postMessage({ pluginMessage: { type: 'export-frame', format, scale } }, '*');
    } catch (e) {
      console.error('Error during export:', e);
      setButtonState(exportBtn, 'default');
      hideProgress();
    }
  };

  // ============================================
  // Cancel Button
  // ============================================
  document.getElementById('cancel').onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
  };

  // ============================================
  // Message Handler
  // ============================================
  window.onmessage = async (event) => {
    const msg = event.data.pluginMessage;
    if (!msg) return;

    // ============================================
    // Selection Change
    // ============================================
    if (msg.type === 'selection-change') {
      if (msg.hasFrame) {
        const frameCount = msg.frameCount || 1;
        frameCountEl.textContent = frameCount === 1 ? '1 frame selected' : `${frameCount} frames selected`;
        frameTagEl.classList.add('has-selection');
      } else {
        frameCountEl.textContent = 'No frames selected';
        frameTagEl.classList.remove('has-selection');
      }
      return;
    }

    // ============================================
    // Progress Updates
    // ============================================
    if (msg.type === 'progress') {
      showProgress(msg.message);
      return;
    }

    // ============================================
    // AI Rename Flow - Process multiple frames through AI in parallel
    // ============================================
    if (msg.type === 'all-frames-for-renaming') {
      const frames = msg.frames || [];
      const totalFrames = msg.totalFrames || frames.length;

      console.log('[UI] Received all-frames-for-renaming:', totalFrames, 'frame(s)');

      try {
        setButtonState(aiRenameBtn, 'loading', 'AI analyzing...');

        // Process frames in parallel batches (3 at a time)
        const BATCH_SIZE = 3;
        const allRenames = [];
        const totalBatches = Math.ceil(frames.length / BATCH_SIZE);
        const overallStartTime = Date.now();

        console.log(`\n${'='.repeat(60)}`);
        console.log(`ðŸš€ AI RENAME STARTING: ${totalFrames} frame(s), ${totalBatches} batch${totalBatches > 1 ? 'es' : ''} of ${BATCH_SIZE}`);
        console.log(`${'='.repeat(60)}\n`);

        for (let batchStart = 0; batchStart < frames.length; batchStart += BATCH_SIZE) {
          const batchEnd = Math.min(batchStart + BATCH_SIZE, frames.length);
          const batch = frames.slice(batchStart, batchEnd);
          const batchNum = Math.floor(batchStart / BATCH_SIZE) + 1;
          const batchStartTime = Date.now();

          console.log(`\nðŸ“¦ BATCH ${batchNum}/${totalBatches}: Processing frames ${batchStart + 1}-${batchEnd}`);
          console.log(`â”€`.repeat(60));

          // Update progress for batch
          const batchFrameNames = batch.map(f => f.frameName).join(', ');
          setButtonState(aiRenameBtn, 'loading', `Processing ${batchNum}/${totalBatches}...`);
          showProgress(`â³ Batch ${batchNum}/${totalBatches}: AI analyzing ${batch.length} frame(s) - ${batchFrameNames}...`);

          // Process all frames in this batch in parallel
          const batchPromises = batch.map((frame, batchIndex) => {
            const frameIndex = batchStart + batchIndex;
            const layerCount = frame.layers.filter(l => l.imageData).length;
            console.log(`  ðŸŽ¯ [${frameIndex + 1}/${totalFrames}] "${frame.frameName}" - ${layerCount} layers`);

            // Update UI with individual frame progress
            showProgress(`â³ Renaming [${frameIndex + 1}/${totalFrames}]: ${frame.frameName} (${layerCount} layers)...`);

            return callRenamingAPI(frame.layers).then(result => {
              console.log(`  âœ… [${frameIndex + 1}/${totalFrames}] "${frame.frameName}" - ${result.layers.length} layers renamed`);

              // Update UI showing completion
              showProgress(`âœ… Renamed [${frameIndex + 1}/${totalFrames}]: ${frame.frameName}`);

              return result.layers; // Return just the renames array
            }).catch(error => {
              console.error(`  âŒ [${frameIndex + 1}/${totalFrames}] "${frame.frameName}" - Error: ${error.message}`);

              // Update UI showing error
              showProgress(`âŒ Failed [${frameIndex + 1}/${totalFrames}]: ${frame.frameName}`);

              throw error;
            });
          });

          // Wait for all frames in this batch to complete
          const batchResults = await Promise.all(batchPromises);

          // Flatten all renames from this batch
          for (const renames of batchResults) {
            allRenames.push(...renames);
          }

          const batchDuration = Date.now() - batchStartTime;
          console.log(`â”€`.repeat(60));
          console.log(`âœ… BATCH ${batchNum}/${totalBatches} COMPLETE: ${batchResults.length} frame(s) processed in ${(batchDuration / 1000).toFixed(1)}s`);
        }

        const overallDuration = Date.now() - overallStartTime;
        console.log(`\n${'='.repeat(60)}`);
        console.log(`ðŸŽ‰ AI RENAME COMPLETE!`);
        console.log(`   Total: ${allRenames.length} layers renamed from ${totalFrames} frame(s)`);
        console.log(`   Time: ${(overallDuration / 1000).toFixed(1)}s total`);
        console.log(`${'='.repeat(60)}\n`);

        // Send all renames back to plugin to apply
        setButtonState(aiRenameBtn, 'loading', 'Applying names...');
        showProgress(`Applying ${allRenames.length} AI-generated names to ${totalFrames} frame(s)...`);

        console.log('[UI] Sending apply-renames to plugin with renames:', allRenames);
        parent.postMessage({
          pluginMessage: {
            type: 'apply-renames',
            renames: allRenames
          }
        }, '*');
        console.log('[UI] apply-renames message sent');
      } catch (error) {
        console.error('[UI] Rename failed:', error);
        setButtonState(aiRenameBtn, 'default');
        hideProgress();

        if (error.message.includes('fetch') || error.message.includes('Failed to fetch')) {
          alert('Cannot connect to AI server.\n\nPlease ensure the server is running:\ncd server && npm run dev');
        } else {
          alert('AI rename failed: ' + error.message);
        }
      }
      return;
    }

    // ============================================
    // AI Rename Complete - show success (decoupled from export)
    // ============================================
    if (msg.type === 'renames-applied') {
      console.log('[UI] Received renames-applied:', msg);

      if (msg.successCount > 0) {
        setButtonState(aiRenameBtn, 'success');
        showProgress(`Renamed ${msg.successCount} of ${msg.totalCount} layers successfully.`);
      } else if (msg.totalCount === 0) {
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
        alert('No layers found to rename.');
      } else {
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
        alert(`Failed to rename layers. ${msg.failCount} errors occurred.`);
      }

      // Reset button after 2 seconds
      setTimeout(() => {
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
      }, 2000);
      return;
    }

    // ============================================
    // Generate Edits Flow - Frame count check
    // ============================================
    if (msg.type === 'frames-count-for-edits') {
      const frameCount = msg.frameCount || 1;

      hideProgress();
      setButtonState(generateEditsBtn, 'default');

      if (frameCount === 0) {
        alert('Please select at least one frame to generate variants.');
        return;
      }

      // If multiple frames, ask for confirmation
      if (frameCount > 1) {
        const totalVariants = frameCount * 5;
        const confirmed = confirm(
          `You have ${frameCount} frames selected.\n\n` +
          `This will generate ${totalVariants} total variants (5 for each frame).\n\n` +
          `This may take several minutes and will use more AI credits.\n\n` +
          `Do you want to continue?`
        );

        if (!confirmed) {
          console.log('[UI] User cancelled multi-frame variant generation');
          return;
        }
      }

      // User confirmed or single frame - proceed
      console.log(`[UI] Proceeding with ${frameCount} frame(s)`);
      setButtonState(generateEditsBtn, 'loading', 'Preparing...');
      showProgress('Extracting layer metadata...');

      parent.postMessage({
        pluginMessage: { type: 'prepare-for-edits', processAllFrames: true }
      }, '*');

      return;
    }

    // ============================================
    // Generate Edits Flow - Receive metadata and call AI
    // ============================================
    if (msg.type === 'metadata-for-edits') {
      const frames = msg.frames || [];
      const totalFrames = msg.totalFrames || frames.length;

      console.log(`[UI] Received metadata for ${totalFrames} frame(s)`);

      try {
        // Check if image generation is enabled
        const generateImagesCheckbox = document.getElementById('generate-images');
        const generateImages = generateImagesCheckbox ? generateImagesCheckbox.checked : false;

        // Process frames in parallel batches (8 at a time for optimal performance)
        const BATCH_SIZE = 8;
        const allFrameVariants = [];
        const totalBatches = Math.ceil(frames.length / BATCH_SIZE);
        const overallStartTime = Date.now();

        console.log(`\n${'='.repeat(60)}`);
        console.log(`ðŸŽ¨ VARIANT GENERATION STARTING: ${totalFrames} frame(s), ${totalBatches} batch${totalBatches > 1 ? 'es' : ''} of ${BATCH_SIZE}`);
        console.log(`   AI Images: ${generateImages ? 'ENABLED âœ¨' : 'Disabled'}`);
        console.log(`${'='.repeat(60)}\n`);

        // Process frames in batches
        for (let batchStart = 0; batchStart < frames.length; batchStart += BATCH_SIZE) {
          const batchEnd = Math.min(batchStart + BATCH_SIZE, frames.length);
          const batch = frames.slice(batchStart, batchEnd);
          const batchNum = Math.floor(batchStart / BATCH_SIZE) + 1;
          const batchStartTime = Date.now();

          console.log(`\nðŸ“¦ BATCH ${batchNum}/${totalBatches}: Processing frames ${batchStart + 1}-${batchEnd}`);
          console.log(`â”€`.repeat(60));

          // Update progress for batch
          const batchFrameNames = batch.map(f => f.frameName).join(', ');
          setButtonState(generateEditsBtn, 'loading', `Generating ${batchNum}/${totalBatches}...`);
          const progressMsg = generateImages
            ? `â³ Batch ${batchNum}/${totalBatches}: Generating variants + AI images for ${batch.length} frame(s)...`
            : `â³ Batch ${batchNum}/${totalBatches}: Generating variants for ${batch.length} frame(s)...`;
          showProgress(progressMsg);

          // Process all frames in this batch in parallel
          const batchPromises = batch.map((frame, batchIndex) => {
            const frameIndex = batchStart + batchIndex;
            const layerCount = frame.layers.filter(l => l.imageData).length;
            console.log(`  ðŸŽ¯ [${frameIndex + 1}/${totalFrames}] "${frame.frameName}" - ${frame.layers.length} layers`);

            // Update UI with individual frame progress
            showProgress(`â³ Processing [${frameIndex + 1}/${totalFrames}]: ${frame.frameName} (${layerCount} layers)...`);

            return callGenerateEditsAPI(
              frame.frameName,
              frame.frameWidth,
              frame.frameHeight,
              frame.layers,
              frame.frameImageBase64,
              generateImages
            ).then(result => {
              console.log(`  âœ… [${frameIndex + 1}/${totalFrames}] "${frame.frameName}" - ${result.variants.length} variants generated`);

              // Update UI showing completion
              showProgress(`âœ… Completed [${frameIndex + 1}/${totalFrames}]: ${frame.frameName}`);

              return {
                frameId: frame.frameId,
                frameName: frame.frameName,
                variants: result.variants
              };
            }).catch(error => {
              console.error(`  âŒ [${frameIndex + 1}/${totalFrames}] "${frame.frameName}" - Error: ${error.message}`);

              // Update UI showing error
              showProgress(`âŒ Failed [${frameIndex + 1}/${totalFrames}]: ${frame.frameName}`);

              throw error;
            });
          });

          // Wait for all frames in this batch to complete
          const batchResults = await Promise.all(batchPromises);
          allFrameVariants.push(...batchResults);

          const batchDuration = Date.now() - batchStartTime;
          const batchVariantCount = batchResults.reduce((sum, f) => sum + f.variants.length, 0);
          console.log(`â”€`.repeat(60));
          console.log(`âœ… BATCH ${batchNum}/${totalBatches} COMPLETE: ${batchResults.length} frame(s), ${batchVariantCount} variants in ${(batchDuration / 1000).toFixed(1)}s`);
        }

        const overallDuration = Date.now() - overallStartTime;
        const totalVariants = allFrameVariants.reduce((sum, f) => sum + f.variants.length, 0);
        console.log(`\n${'='.repeat(60)}`);
        console.log(`ðŸŽ‰ VARIANT GENERATION COMPLETE!`);
        console.log(`   Total: ${totalVariants} variants from ${totalFrames} frame(s)`);
        console.log(`   Time: ${(overallDuration / 1000).toFixed(1)}s total`);
        console.log(`   Avg: ${(overallDuration / totalFrames / 1000).toFixed(1)}s per frame`);
        console.log(`${'='.repeat(60)}\n`);

        // Send all variants back to plugin to apply
        setButtonState(generateEditsBtn, 'loading', 'Applying edits...');
        showProgress(`Generated variants for ${totalFrames} frame(s). Applying edits to canvas...`);

        parent.postMessage({
          pluginMessage: {
            type: 'apply-edit-variants',
            frameVariants: allFrameVariants,
            totalFrames: totalFrames
          }
        }, '*');

      } catch (error) {
        console.error('[UI] Generate edits failed:', error);
        setButtonState(generateEditsBtn, 'default');
        hideProgress();

        if (error.message.includes('fetch') || error.message.includes('Failed to fetch')) {
          alert('Cannot connect to AI server.\n\nPlease ensure the server is running:\ncd server && npm run dev');
        } else {
          alert('Generate edits failed: ' + error.message);
        }
      }
      return;
    }

    // ============================================
    // Export Data (both regular and AI flow use this)
    // ============================================
    if (msg.type === 'export-data') {
      try {
        // Validate required data
        if (!msg.meta || !msg.layers || !msg.folderName) {
          throw new Error('Missing required export data. Please try again.');
        }

        if (!msg.meta.component || !msg.meta.layers) {
          throw new Error('Invalid metadata structure. Please try again.');
        }

        const frameInfo = msg.totalFrames > 1
          ? ` (${msg.frameIndex + 1}/${msg.totalFrames})`
          : '';

        showProgress(`Processing frame ${msg.frameIndex + 1} of ${msg.totalFrames}...`);

        let reconstructedBlob;
        const exportFormat = msg.format || 'png';

        if (exportFormat === 'svg') {
          // SVG reconstruction
          // Sort layers by z-index
          const sortedLayers = msg.meta.layers
            .filter(layer => layer.visible)
            .sort((a, b) => a.z - b.z);

          // Build SVG content
          let svgContent = `<svg width="${msg.meta.component.width}" height="${msg.meta.component.height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n`;

          for (const layer of sortedLayers) {
            const layerData = msg.layers.find(l => l.filename === createFilename(layer.name, layer.id, 'svg'));
            if (!layerData) continue;

            // Decode base64 SVG
            const svgText = atob(layerData.data);

            // Use export bounds if available
            const useX = layer.exportX !== undefined ? layer.exportX : layer.x;
            const useY = layer.exportY !== undefined ? layer.exportY : layer.y;

            // Wrap in a group with transform for positioning
            svgContent += `  <g transform="translate(${useX}, ${useY})">\n`;
            svgContent += `    ${svgText}\n`;
            svgContent += `  </g>\n`;
          }

          svgContent += '</svg>';

          // Convert SVG to blob
          reconstructedBlob = new Blob([svgContent], { type: 'image/svg+xml' });

        } else {
          // PNG reconstruction
          // Get scale factor from metadata (default to 2 for backwards compatibility)
          const scale = msg.meta.scale || 2;

          // Create canvas at the SCALED resolution to match exported layers
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(msg.meta.component.width * scale);
          canvas.height = Math.round(msg.meta.component.height * scale);
          const ctx = canvas.getContext('2d');

          // Sort layers by z-index
          const sortedLayers = msg.meta.layers
            .filter(layer => layer.visible)
            .sort((a, b) => a.z - b.z);

          // Load and draw all layer images
          const loadPromises = [];
          for (let i = 0; i < sortedLayers.length; i++) {
            const layer = sortedLayers[i];
            const layerData = msg.layers.find(l => l.filename === createFilename(layer.name, layer.id, 'png'));

            if (!layerData) continue;

            const promise = new Promise((resolve, reject) => {
              const img = new Image();
              img.onload = () => {
                // Use export bounds if available (for accurate positioning of effects, strokes, etc.)
                // Otherwise fall back to node bounds
                const useX = layer.exportX !== undefined ? layer.exportX : layer.x;
                const useY = layer.exportY !== undefined ? layer.exportY : layer.y;

                // Both canvas and images are at the same scale
                const layerX = Math.round(useX * scale);
                const layerY = Math.round(useY * scale);

                // Actual image dimensions at the exported scale
                const imgWidth = img.naturalWidth || img.width;
                const imgHeight = img.naturalHeight || img.height;

                // Calculate clipping in scaled space
                const sx = Math.max(0, -layerX);
                const sy = Math.max(0, -layerY);
                const sw = Math.min(imgWidth - sx, canvas.width - Math.max(0, layerX));
                const sh = Math.min(imgHeight - sy, canvas.height - Math.max(0, layerY));

                // Draw position in scaled space
                const dx = Math.max(0, layerX);
                const dy = Math.max(0, layerY);

                if (sw > 0 && sh > 0) {
                  ctx.drawImage(img, sx, sy, sw, sh, dx, dy, sw, sh);
                }
                resolve();
              };
              img.onerror = reject;
              img.src = 'data:image/png;base64,' + layerData.data;
            });

            loadPromises.push(promise);
          }

          // Wait for all images to be drawn
          await Promise.all(loadPromises);

          // Convert canvas to blob
          reconstructedBlob = await new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error('Failed to create image blob'));
              }
            }, 'image/png');
          });
        }

        // Store export data for this frame
        frameExportData.push({
          folderName: msg.folderName,
          meta: msg.meta,
          layers: msg.layers,
          reconstructedBlob,
          format: exportFormat,
          frameIndex: msg.frameIndex,
          totalFrames: msg.totalFrames,
          aiPromptTheme: msg.aiPromptTheme,
          aiPromptInstructions: msg.aiPromptInstructions
        });

        console.log(`[UI] Collected frame ${msg.frameIndex + 1}/${msg.totalFrames}: ${msg.folderName}`);

        // If this is the last frame OR single frame, process immediately
        if (msg.frameIndex + 1 === msg.totalFrames) {
          // Don't process here - wait for 'all-exports-complete' message
          console.log(`[UI] All ${msg.totalFrames} frames collected, waiting for completion signal...`);
        }

      } catch (error) {
        console.error('Error creating ZIP:', error);
        alert('Export failed: ' + error.message);
        setButtonState(exportBtn, 'default');
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
      }
    }

    // ============================================
    // All Exports Complete
    // ============================================
    if (msg.type === 'all-exports-complete') {
      const expectedFrames = msg.totalFrames || 1;

      // Check if we've received all frame data yet
      if (frameExportData.length < expectedFrames) {
        console.log(`[UI] Completion signal received, but only have ${frameExportData.length}/${expectedFrames} frames. Waiting...`);

        // Retry after a short delay to allow frame data to be processed
        setTimeout(() => {
          window.postMessage({ pluginMessage: { type: 'all-exports-complete', totalFrames: expectedFrames } }, '*');
        }, 100);
        return;
      }

      try {
        if (frameExportData.length === 0) {
          throw new Error('No frame data to export');
        }

        showProgress('Creating ZIP file...');

        const totalFrames = frameExportData.length;

        // Group frames by their base name (everything before _v1, _v2, etc.)
        // e.g., "00560_v1_ecomodern_rebrand" â†’ "00560"
        const frameGroups = {};

        for (const frameData of frameExportData) {
          // Extract base frame number (e.g., "00560" from "00560_v1_ecomodern_rebrand")
          const match = frameData.folderName.match(/^(\d+)/);
          const baseFrameName = match ? match[1] : frameData.folderName;

          if (!frameGroups[baseFrameName]) {
            frameGroups[baseFrameName] = [];
          }
          frameGroups[baseFrameName].push(frameData);
        }

        console.log(`[UI] Grouped ${totalFrames} frames into ${Object.keys(frameGroups).length} base frame(s)`);

        // Create parent ZIP
        const parentZip = new JSZip();
        const baseFrameNames = Object.keys(frameGroups);

        // Create a frame-level ZIP for each base frame
        for (let groupIndex = 0; groupIndex < baseFrameNames.length; groupIndex++) {
          const baseFrameName = baseFrameNames[groupIndex];
          const variants = frameGroups[baseFrameName];

          showProgress(`Creating ZIP for frame ${baseFrameName} (${variants.length} variant${variants.length > 1 ? 's' : ''})...`);
          console.log(`[UI] Creating frame-level ZIP: ${baseFrameName}.zip with ${variants.length} variant(s)`);

          // Create frame-level ZIP
          const frameZip = new JSZip();

          // Add each variant as a folder in the frame-level ZIP
          for (let i = 0; i < variants.length; i++) {
            const frameData = variants[i];

            // Add meta.json with validation
            const metaWithFormat = { ...frameData.meta, format: frameData.format };
            let metaJson;
            try {
              metaJson = JSON.stringify(metaWithFormat, null, 2);
              if (!metaJson || metaJson === '{}') {
                throw new Error(`Failed to serialize metadata for ${frameData.folderName}`);
              }
            } catch (e) {
              throw new Error(`Failed to create metadata file for ${frameData.folderName}: ` + e.message);
            }

            frameZip.file(`${frameData.folderName}/meta.json`, metaJson);

            // Add all layer files (PNG or SVG)
            const layersFolder = frameZip.folder(`${frameData.folderName}/layers`);
            for (const layer of frameData.layers) {
              layersFolder.file(layer.filename, layer.data, { base64: true });
            }

            // Add reconstructed image with correct extension
            const reconstructedExt = frameData.format === 'svg' ? '.svg' : '.png';

            // Validate reconstructed blob before adding
            if (!frameData.reconstructedBlob) {
              throw new Error(`Failed to create reconstructed image for ${frameData.folderName}`);
            }

            frameZip.file(
              `${frameData.folderName}/${frameData.meta.component.name}_reconstructed${reconstructedExt}`,
              frameData.reconstructedBlob
            );

            // Add AI prompt text file if available (from generated variants)
            if (frameData.aiPromptTheme || frameData.aiPromptInstructions) {
              let promptContent = '';

              // Add theme description
              if (frameData.aiPromptTheme) {
                promptContent += frameData.aiPromptTheme + '\n\n';
              }

              // Add detailed instructions
              if (frameData.aiPromptInstructions) {
                promptContent += frameData.aiPromptInstructions;
              }

              frameZip.file(`${frameData.folderName}/prompt.txt`, promptContent.trim());
            }

            console.log(`[UI] Added variant to ${baseFrameName}.zip: ${frameData.folderName}`);
          }

          // Generate frame-level ZIP blob
          const frameZipBlob = await frameZip.generateAsync({
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: {
              level: 6
            },
            platform: 'UNIX'
          });

          // Add frame-level ZIP to parent ZIP
          parentZip.file(`${baseFrameName}.zip`, frameZipBlob);
          console.log(`[UI] Added ${baseFrameName}.zip to parent ZIP`);

          // Upload frame ZIP to S3
          await uploadFrameToS3(baseFrameName, frameZipBlob, variants.length, currentUserEmail);
        }

        // Determine parent ZIP filename
        let zipFilename;
        if (baseFrameNames.length === 1) {
          // Single base frame: just download the frame ZIP directly
          zipFilename = `${baseFrameNames[0]}.zip`;
        } else {
          // Multiple base frames: create parent ZIP
          zipFilename = `figma-export-${baseFrameNames.length}-frames.zip`;
        }

        // Generate final ZIP
        showProgress('Finalizing ZIP file...');
        const blob = await parentZip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: {
            level: 6
          },
          platform: 'UNIX'
        });

        // Validate ZIP blob
        if (!blob || blob.size === 0) {
          throw new Error('Failed to generate ZIP file');
        }

        // Trigger download
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = zipFilename;
        a.click();
        URL.revokeObjectURL(url);

        console.log(`[UI] Downloaded: ${zipFilename} (${baseFrameNames.length} base frame${baseFrameNames.length > 1 ? 's' : ''}, ${totalFrames} total variants)`);

        // Clear stored data for next export
        frameExportData = [];

        // Show success state in all buttons (whichever was active)
        setButtonState(exportBtn, 'success');
        setButtonState(aiRenameBtn, 'success');
        hideProgress();

      } catch (error) {
        console.error('Error creating final ZIP:', error);
        alert('Export failed: ' + error.message);
        setButtonState(exportBtn, 'default');
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
        frameExportData = []; // Clear on error
      }
    }

    // ============================================
    // Variants Created (Generate Edits complete)
    // ============================================
    if (msg.type === 'variants-created') {
      setButtonState(generateEditsBtn, 'success');
      hideProgress();
      console.log(`[UI] Created ${msg.variantCount} variants successfully`);
    }

    // ============================================
    // Groups Broken (Break Groups complete)
    // ============================================
    if (msg.type === 'groups-broken') {
      setButtonState(breakGroupsBtn, 'success');
      if (msg.groupCount > 0) {
        showProgress(`Ungrouped ${msg.groupCount} groups into ${msg.layerCount} layers.`);
      } else {
        showProgress('No groups found in selection.');
      }
      console.log(`[UI] Broke ${msg.groupCount} groups into ${msg.layerCount} layers`);

      setTimeout(() => {
        setButtonState(breakGroupsBtn, 'default');
        hideProgress();
      }, 2000);
      return;
    }

    // ============================================
    // Rasterize Complete
    // ============================================
    if (msg.type === 'rasterize-complete') {
      setButtonState(rasterizeBtn, 'success');
      if (msg.count > 0) {
        showProgress(`Rasterized ${msg.count} objects at 4x resolution.`);
      } else {
        showProgress('No objects found to rasterize.');
      }
      console.log(`[UI] Rasterized ${msg.count} objects`);

      setTimeout(() => {
        setButtonState(rasterizeBtn, 'default');
        hideProgress();
      }, 2000);
      return;
    }

    // ============================================
    // Error Handler
    // ============================================
    if (msg.type === 'error') {
      alert(msg.message);
      setButtonState(exportBtn, 'default');
      setButtonState(aiRenameBtn, 'default');
      setButtonState(generateEditsBtn, 'default');
      setButtonState(breakGroupsBtn, 'default');
      setButtonState(rasterizeBtn, 'default');
      hideProgress();
    }
  };

</script>