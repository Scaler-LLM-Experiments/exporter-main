<style>
  @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap');

  :root {
    /* Monochrome neutral palette */
    --background: 0 0% 100%;
    --foreground: 0 0% 9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --success: 0 0% 9%;
    --success-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 9%;
    --radius: 0.5rem;
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: 'Manrope', -apple-system, BlinkMacSystemFont, sans-serif;
    padding: 1.25rem;
    margin: 0;
    background: hsl(var(--background));
    color: hsl(var(--foreground));
    font-size: 14px;
    line-height: 1.5;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  h2 {
    margin: 0 0 0.375rem 0;
    font-size: 16px;
    font-weight: 800;
    letter-spacing: 0.3em;
    color: hsl(var(--foreground));
    text-transform: uppercase;
  }

  .description {
    margin: 0 0 0.875rem 0;
    font-size: 11px;
    color: hsl(var(--muted-foreground));
    line-height: 1.4;
  }

  /* Status Alert Styles */
  .status {
    margin: 0 0 0.875rem 0;
    padding: 0.625rem 0.875rem;
    border-radius: var(--radius);
    font-size: 0.8125rem;
    min-height: 2.25rem;
    display: flex;
    align-items: center;
    border: 1px solid hsl(var(--border));
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
  }

  .status.error {
    background: hsl(var(--destructive) / 0.1);
    color: hsl(var(--destructive));
    border-color: hsl(var(--destructive) / 0.3);
  }

  .status.success {
    background: hsl(var(--success) / 0.1);
    color: hsl(var(--success));
    border-color: hsl(var(--success) / 0.3);
  }

  /* Button Styles */
  button {
    width: 100%;
    padding: 0.5rem 1rem;
    margin-top: 0;
    margin-bottom: 0.5rem;
    border: 1px solid transparent;
    border-radius: var(--radius);
    font-family: inherit;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 150ms ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    height: 2.5rem;
  }

  button:last-child {
    margin-bottom: 0;
  }

  button:focus-visible {
    outline: none;
    ring: 2px;
    ring-color: hsl(var(--ring));
    ring-offset: 2px;
  }

  #export {
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  }

  #export:hover:not(:disabled) {
    background: hsl(var(--primary) / 0.9);
  }

  #export:active:not(:disabled) {
    background: hsl(var(--primary) / 0.95);
  }

  #export:disabled {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    cursor: not-allowed;
    opacity: 0.6;
  }

  #cancel {
    background: hsl(var(--background));
    color: hsl(var(--foreground));
    border: 1px solid hsl(var(--border));
  }

  #cancel:hover {
    background: hsl(var(--accent));
    color: hsl(var(--accent-foreground));
  }

  #cancel:active {
    background: hsl(var(--accent) / 0.8);
  }

  /* AI Rename Button Styles */
  #ai-rename {
    background: linear-gradient(135deg, hsl(250 60% 50%) 0%, hsl(280 60% 50%) 100%);
    color: white;
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    margin-bottom: 0.5rem;
  }

  #ai-rename:hover:not(:disabled) {
    background: linear-gradient(135deg, hsl(250 60% 45%) 0%, hsl(280 60% 45%) 100%);
  }

  #ai-rename:active:not(:disabled) {
    background: linear-gradient(135deg, hsl(250 60% 40%) 0%, hsl(280 60% 40%) 100%);
  }

  #ai-rename:disabled {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    cursor: not-allowed;
    opacity: 0.6;
  }

  /* Break Groups Button Styles */
  #break-groups {
    background: linear-gradient(135deg, hsl(180 60% 45%) 0%, hsl(200 60% 50%) 100%);
    color: white;
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    margin-bottom: 0.5rem;
  }

  #break-groups:hover:not(:disabled) {
    background: linear-gradient(135deg, hsl(180 60% 40%) 0%, hsl(200 60% 45%) 100%);
  }

  #break-groups:active:not(:disabled) {
    background: linear-gradient(135deg, hsl(180 60% 35%) 0%, hsl(200 60% 40%) 100%);
  }

  #break-groups:disabled {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    cursor: not-allowed;
    opacity: 0.6;
  }

  /* Rasterize Button Styles */
  #rasterize {
    background: linear-gradient(135deg, hsl(145 60% 42%) 0%, hsl(160 60% 45%) 100%);
    color: white;
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    margin-bottom: 0.5rem;
  }

  #rasterize:hover:not(:disabled) {
    background: linear-gradient(135deg, hsl(145 60% 37%) 0%, hsl(160 60% 40%) 100%);
  }

  #rasterize:active:not(:disabled) {
    background: linear-gradient(135deg, hsl(145 60% 32%) 0%, hsl(160 60% 35%) 100%);
  }

  #rasterize:disabled {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    cursor: not-allowed;
    opacity: 0.6;
  }

  /* Generate Edits Button Styles */
  #generate-edits {
    background: linear-gradient(135deg, hsl(30 80% 50%) 0%, hsl(45 80% 50%) 100%);
    color: white;
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    margin-bottom: 0.5rem;
  }

  #generate-edits:hover:not(:disabled) {
    background: linear-gradient(135deg, hsl(30 80% 45%) 0%, hsl(45 80% 45%) 100%);
  }

  #generate-edits:active:not(:disabled) {
    background: linear-gradient(135deg, hsl(30 80% 40%) 0%, hsl(45 80% 40%) 100%);
  }

  #generate-edits:disabled {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    cursor: not-allowed;
    opacity: 0.6;
  }

  /* Progress Status */
  .progress-status {
    margin: 0 0 0.875rem 0;
    padding: 0.625rem 0.875rem;
    border-radius: var(--radius);
    font-size: 0.75rem;
    border: 1px solid hsl(var(--border));
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    display: none;
  }

  .progress-status.visible {
    display: block;
  }

  /* Frame Selector Styles */
  .frame-selector {
    margin: 0 0 1.5rem 0;
    padding: 1.5rem;
    background: hsl(var(--card));
    border: 1px solid hsl(var(--border));
    border-radius: var(--radius);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
  }

  .frame-icon {
    color: hsl(var(--muted-foreground));
    position: relative;
  }

  .frame-icon svg {
    display: block;
  }

  .frame-icon .checkmark {
    transition: opacity 200ms ease;
  }

  .frame-name {
    font-size: 0.875rem;
    font-weight: 500;
    color: hsl(var(--foreground));
    text-align: center;
    max-width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Button Icon Styles */
  .btn-icon {
    display: inline-block;
    margin-right: 0.5rem;
    width: 1rem;
    height: 1rem;
  }

  .spinner {
    animation: spin 1s linear infinite;
    width: 1rem;
    height: 1rem;
  }

  @keyframes spin {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }

  .hidden {
    display: none;
  }

  /* Checkbox Styles */
  .checkbox-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: var(--radius);
    background: hsl(var(--muted) / 0.5);
    border: 1px solid hsl(var(--border));
    cursor: pointer;
    transition: all 150ms ease;
  }

  .checkbox-container:hover {
    background: hsl(var(--muted));
  }

  .checkbox-container input[type="checkbox"] {
    width: 1rem;
    height: 1rem;
    margin: 0;
    accent-color: hsl(30 80% 50%);
    cursor: pointer;
  }

  .checkbox-container label {
    font-size: 0.8125rem;
    color: hsl(var(--foreground));
    cursor: pointer;
    user-select: none;
    flex: 1;
  }

  .checkbox-container .checkbox-hint {
    font-size: 0.6875rem;
    color: hsl(var(--muted-foreground));
  }

  /* Select/Dropdown Styles */
  .select-container {
    margin-bottom: 0.5rem;
  }

  .select-container label {
    display: block;
    font-size: 0.75rem;
    color: hsl(var(--muted-foreground));
    margin-bottom: 0.375rem;
    font-weight: 500;
  }

  select {
    width: 100%;
    padding: 0.5rem 0.75rem;
    font-family: inherit;
    font-size: 0.8125rem;
    color: hsl(var(--foreground));
    background: hsl(var(--background));
    border: 1px solid hsl(var(--border));
    border-radius: var(--radius);
    cursor: pointer;
    transition: all 150ms ease;
  }

  select:hover {
    border-color: hsl(var(--foreground) / 0.3);
  }

  select:focus {
    outline: none;
    border-color: hsl(var(--foreground));
    box-shadow: 0 0 0 2px hsl(var(--foreground) / 0.1);
  }

  select:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
</style>

<h2>Exporter</h2>
<p class="description">Export your designs for taggr submissions</p>

<div class="progress-status" id="progress-status"></div>

<div class="frame-selector">
  <div class="frame-icon">
    <svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect x="16" y="16" width="32" height="32" rx="4" stroke="currentColor" stroke-width="2" fill="none" />
      <line x1="32" y1="16" x2="32" y2="48" stroke="currentColor" stroke-width="2" />
      <line x1="16" y1="32" x2="48" y2="32" stroke="currentColor" stroke-width="2" />
      <circle class="checkmark hidden" cx="48" cy="16" r="10" fill="hsl(var(--success))" />
      <path class="checkmark hidden" d="M 44 16 L 47 19 L 52 13" stroke="white" stroke-width="2" stroke-linecap="round"
        stroke-linejoin="round" fill="none" />
    </svg>
  </div>
  <div class="frame-name" id="frame-name">Select Frame to Export</div>
</div>

<button id="break-groups">
  <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
    <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
  </svg>
  <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
  </svg>
  <span class="btn-text">Break Groups Apart</span>
</button>
<button id="rasterize">
  <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
    <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
  </svg>
  <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
  </svg>
  <span class="btn-text">Rasterize Selection (4x)</span>
</button>
<button id="ai-rename">
  <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
    <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
  </svg>
  <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
  </svg>
  <span class="btn-text">AI Rename Layers</span>
</button>
<div class="checkbox-container" onclick="document.getElementById('generate-images').click(); event.stopPropagation();">
  <input type="checkbox" id="generate-images" onclick="event.stopPropagation();">
  <label for="generate-images">Generate AI Images</label>
  <span class="checkbox-hint">Requires OpenRouter</span>
</div>
<div class="select-container">
  <label for="prompt-selector">AI Prompt Style</label>
  <select id="prompt-selector">
    <option value="">Loading prompts...</option>
  </select>
</div>
<button id="generate-edits">
  <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
    <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
  </svg>
  <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
  </svg>
  <span class="btn-text">Generate Edits (5 variants)</span>
</button>
<button id="export">
  <svg class="btn-icon spinner hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="8" cy="8" r="6" stroke-opacity="0.25" />
    <path d="M 8 2 A 6 6 0 0 1 14 8" stroke-linecap="round" />
  </svg>
  <svg class="btn-icon check-icon hidden" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M 3 8 L 6 11 L 13 4" stroke-linecap="round" stroke-linejoin="round" />
  </svg>
  <span class="btn-text">Export Only</span>
</button>
<button id="cancel">Cancel</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>

  // ============================================
  // DOM Elements
  // ============================================
  const exportBtn = document.getElementById('export');
  const aiRenameBtn = document.getElementById('ai-rename');
  const generateEditsBtn = document.getElementById('generate-edits');
  const breakGroupsBtn = document.getElementById('break-groups');
  const rasterizeBtn = document.getElementById('rasterize');
  const frameNameEl = document.getElementById('frame-name');
  const checkmarks = document.querySelectorAll('.checkmark');
  const progressStatus = document.getElementById('progress-status');
  const promptSelector = document.getElementById('prompt-selector');

  // Backend server URL
  // IMPORTANT: Update this to your Railway URL after deployment!
  // Format: https://your-app-name.up.railway.app
  const BACKEND_URL = 'http://localhost:3000'; // Change to Railway URL for production
  console.log('[UI] Backend URL:', BACKEND_URL);

  // Store user email (captured from plugin messages)
  let currentUserEmail = 'unknown@figma.local';

  // Store selected prompt file
  let selectedPromptFile = 'default.txt';

  // Store multiple frame exports (for single ZIP with folders)
  let frameExportData = [];

  // Helper to create filename from layer name (matching code.ts logic)
  function createFilename(name, id, ext = 'png') {
    // Sanitize the layer name: remove/replace invalid filename characters
    const safeName = name
      .replace(/[<>:"/\\|?*]/g, '_')  // Replace invalid filename chars
      .replace(/\s+/g, '_')            // Replace spaces with underscores
      .replace(/_+/g, '_')             // Collapse multiple underscores
      .replace(/^_|_$/g, '')           // Trim leading/trailing underscores
      .substring(0, 100);              // Limit length

    // Use sanitized name, fallback to ID if name is empty
    const baseName = safeName || id.replace(/:/g, '_');
    return `${baseName}.${ext}`;
  }

  // ============================================
  // Button State Management
  // ============================================
  function setButtonState(button, state, text) {
    const btnText = button.querySelector('.btn-text');
    const spinnerIcon = button.querySelector('.spinner');
    const checkIcon = button.querySelector('.check-icon');

    let defaultText = 'Export Only';
    if (button.id === 'ai-rename') {
      defaultText = 'AI Rename Layers';
    } else if (button.id === 'generate-edits') {
      defaultText = 'Generate Edits (5 variants)';
    } else if (button.id === 'break-groups') {
      defaultText = 'Break Groups Apart';
    } else if (button.id === 'rasterize') {
      defaultText = 'Rasterize Selection (4x)';
    }

    switch (state) {
      case 'loading':
        button.disabled = true;
        btnText.textContent = text || 'Processing...';
        spinnerIcon.classList.remove('hidden');
        checkIcon.classList.add('hidden');
        break;
      case 'success':
        button.disabled = false;
        btnText.textContent = defaultText;
        spinnerIcon.classList.add('hidden');
        checkIcon.classList.remove('hidden');
        setTimeout(() => setButtonState(button, 'default'), 2000);
        break;
      case 'default':
      default:
        button.disabled = false;
        btnText.textContent = defaultText;
        spinnerIcon.classList.add('hidden');
        checkIcon.classList.add('hidden');
        break;
    }
  }

  function showProgress(message) {
    progressStatus.textContent = message;
    progressStatus.classList.add('visible');
  }

  function hideProgress() {
    progressStatus.classList.remove('visible');
  }

  // ============================================
  // Backend API Calls
  // ============================================
  async function callRenamingAPI(layers) {
    const response = await fetch(`${BACKEND_URL}/api/rename-layers`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userEmail: currentUserEmail, // Add user email
        layers: layers
          .filter(l => l.imageData) // Only send layers with image data
          .map(l => ({
            id: l.id,
            imageBase64: l.imageData,
            currentName: l.name,
            type: l.type
          }))
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.message || `Server error: ${response.statusText}`);
    }

    return response.json();
  }

  async function callGenerateEditsAPI(frameName, frameWidth, frameHeight, layers, frameImageBase64, generateImages = false) {
    const response = await fetch(`${BACKEND_URL}/api/generate-edits`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userEmail: currentUserEmail, // Add user email
        frameName,
        frameWidth,
        frameHeight,
        frameImageBase64,  // Include frame image for AI vision analysis
        generateImages,    // Whether to generate AI images for image layers
        promptFile: selectedPromptFile, // User-selected prompt style
        layers: layers.map(l => ({
          name: l.name,
          type: l.type,
          x: l.x,
          y: l.y,
          width: l.width,
          height: l.height,
          fills: l.fills,
          strokes: l.strokes,
          opacity: l.opacity,
          text: l.text,
          fontSize: l.fontSize,
          cornerRadius: l.cornerRadius,
          hasImageFill: l.hasImageFill  // Pass through image fill info
        }))
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `Server error: ${response.statusText}`);
    }

    return response.json();
  }

  // ============================================
  // Fetch and Populate Prompts
  // ============================================
  async function loadPrompts() {
    try {
      console.log('[UI] Fetching available prompts...');
      const response = await fetch(`${BACKEND_URL}/api/prompts`);

      if (!response.ok) {
        throw new Error('Failed to fetch prompts');
      }

      const data = await response.json();
      const prompts = data.prompts || [];

      console.log(`[UI] Loaded ${prompts.length} prompts:`, prompts);

      // Clear existing options
      promptSelector.innerHTML = '';

      // Populate dropdown
      prompts.forEach(prompt => {
        const option = document.createElement('option');
        option.value = prompt.filename;
        option.textContent = prompt.name;
        if (prompt.isDefault) {
          option.selected = true;
          selectedPromptFile = prompt.filename;
        }
        promptSelector.appendChild(option);
      });

      console.log(`[UI] Selected prompt: ${selectedPromptFile}`);
    } catch (error) {
      console.error('[UI] Error loading prompts:', error);
      // Fallback to default
      promptSelector.innerHTML = '<option value="default.txt">Default</option>';
      selectedPromptFile = 'default.txt';
    }
  }

  // Update selected prompt when user changes selection
  promptSelector.addEventListener('change', (e) => {
    selectedPromptFile = e.target.value;
    console.log(`[UI] Prompt changed to: ${selectedPromptFile}`);
  });

  // Load prompts on page load
  loadPrompts();

  // ============================================
  // Break Groups Apart Flow
  // ============================================
  breakGroupsBtn.onclick = () => {
    console.log('Break Groups button clicked');
    try {
      setButtonState(breakGroupsBtn, 'loading', 'Breaking groups...');
      showProgress('Breaking groups apart...');

      parent.postMessage({
        pluginMessage: { type: 'break-groups' }
      }, '*');
    } catch (e) {
      console.error('Break Groups error:', e);
      setButtonState(breakGroupsBtn, 'default');
      hideProgress();
      alert('Error: ' + e.message);
    }
  };

  // ============================================
  // Rasterize Selection Flow
  // ============================================
  rasterizeBtn.onclick = () => {
    console.log('Rasterize button clicked');
    try {
      setButtonState(rasterizeBtn, 'loading', 'Rasterizing...');
      showProgress('Converting to raster images at 4x resolution...');

      parent.postMessage({
        pluginMessage: { type: 'rasterize-selection' }
      }, '*');
    } catch (e) {
      console.error('Rasterize error:', e);
      setButtonState(rasterizeBtn, 'default');
      hideProgress();
      alert('Error: ' + e.message);
    }
  };

  // ============================================
  // AI Rename Flow (decoupled from export)
  // ============================================
  aiRenameBtn.onclick = async () => {
    console.log('AI Rename button clicked');
    try {
      setButtonState(aiRenameBtn, 'loading', 'Preparing...');
      showProgress('Starting AI rename process...');

      // Request layer images for renaming
      parent.postMessage({
        pluginMessage: { type: 'export-for-renaming' }
      }, '*');
    } catch (e) {
      console.error('AI Rename error:', e);
      setButtonState(aiRenameBtn, 'default');
      hideProgress();
      alert('Error: ' + e.message);
    }
  };

  // ============================================
  // Generate Edits Flow
  // ============================================
  generateEditsBtn.onclick = async () => {
    console.log('Generate Edits button clicked');
    try {
      setButtonState(generateEditsBtn, 'loading', 'Preparing...');
      showProgress('Extracting layer metadata...');

      // Request layer metadata for edit generation
      parent.postMessage({
        pluginMessage: { type: 'prepare-for-edits' }
      }, '*');
    } catch (e) {
      console.error('Generate Edits error:', e);
      setButtonState(generateEditsBtn, 'default');
      hideProgress();
      alert('Error: ' + e.message);
    }
  };

  // ============================================
  // Regular Export Flow
  // ============================================
  exportBtn.onclick = () => {
    console.log('Export button clicked');
    try {
      // Clear any previous export data
      frameExportData = [];

      setButtonState(exportBtn, 'loading', 'Exporting...');
      showProgress('Exporting frame...');

      const format = 'png';
      const scale = 4;

      parent.postMessage({ pluginMessage: { type: 'export-frame', format, scale } }, '*');
    } catch (e) {
      console.error('Error during export:', e);
      setButtonState(exportBtn, 'default');
      hideProgress();
    }
  };

  // ============================================
  // Cancel Button
  // ============================================
  document.getElementById('cancel').onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
  };

  // ============================================
  // Message Handler
  // ============================================
  window.onmessage = async (event) => {
    const msg = event.data.pluginMessage;
    if (!msg) return;

    // ============================================
    // Selection Change
    // ============================================
    if (msg.type === 'selection-change') {
      if (msg.hasFrame) {
        frameNameEl.textContent = msg.frameName;
        checkmarks.forEach(checkmark => checkmark.classList.remove('hidden'));
      } else {
        frameNameEl.textContent = 'Select Frame to Export';
        checkmarks.forEach(checkmark => checkmark.classList.add('hidden'));
      }
      return;
    }

    // ============================================
    // Progress Updates
    // ============================================
    if (msg.type === 'progress') {
      showProgress(msg.message);
      return;
    }

    // ============================================
    // AI Rename Flow - Process layers through AI
    // ============================================
    if (msg.type === 'layers-for-renaming') {
      // Capture user email
      if (msg.userEmail) {
        currentUserEmail = msg.userEmail;
        console.log('[UI] User email captured:', currentUserEmail);
      }

      console.log('[UI] Received layers-for-renaming:', msg.layers.length, 'layers');
      console.log('[UI] Layer IDs:', msg.layers.map(l => l.id));
      try {
        setButtonState(aiRenameBtn, 'loading', 'AI analyzing...');
        showProgress(`Sending ${msg.layers.length} layers to AI for naming...`);

        // Call backend to get AI-generated names
        console.log('[UI] Calling backend API...');
        const result = await callRenamingAPI(msg.layers);
        console.log('[UI] Backend response received:', JSON.stringify(result, null, 2));

        // Send renames back to plugin
        setButtonState(aiRenameBtn, 'loading', 'Applying names...');
        showProgress(`Applying ${result.layers.length} AI-generated names...`);

        console.log('[UI] Sending apply-renames to plugin with renames:', result.layers);
        parent.postMessage({
          pluginMessage: {
            type: 'apply-renames',
            renames: result.layers
          }
        }, '*');
        console.log('[UI] apply-renames message sent');
      } catch (error) {
        console.error('[UI] AI renaming failed:', error);
        setButtonState(aiRenameBtn, 'default');
        hideProgress();

        if (error.message.includes('fetch') || error.message.includes('Failed to fetch')) {
          alert('Cannot connect to AI server.\n\nPlease ensure the server is running:\ncd server && npm run dev');
        } else {
          alert('AI renaming failed: ' + error.message);
        }
      }
      return;
    }

    // ============================================
    // AI Rename Complete - show success (decoupled from export)
    // ============================================
    if (msg.type === 'renames-applied') {
      console.log('[UI] Received renames-applied:', msg);

      if (msg.successCount > 0) {
        setButtonState(aiRenameBtn, 'success');
        showProgress(`Renamed ${msg.successCount} of ${msg.totalCount} layers successfully.`);
      } else if (msg.totalCount === 0) {
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
        alert('No layers found to rename.');
      } else {
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
        alert(`Failed to rename layers. ${msg.failCount} errors occurred.`);
      }

      // Reset button after 2 seconds
      setTimeout(() => {
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
      }, 2000);
      return;
    }

    // ============================================
    // Generate Edits Flow - Receive metadata and call AI
    // ============================================
    if (msg.type === 'metadata-for-edits') {
      // Capture user email
      if (msg.userEmail) {
        currentUserEmail = msg.userEmail;
        console.log('[UI] User email captured:', currentUserEmail);
      }

      console.log('[UI] Received metadata-for-edits:', msg.layers.length, 'layers');
      console.log('[UI] Frame image included:', !!msg.frameImageBase64, msg.frameImageBase64 ? `(${Math.round(msg.frameImageBase64.length / 1024)}KB)` : '');
      try {
        // Check if image generation is enabled
        const generateImagesCheckbox = document.getElementById('generate-images');
        const generateImages = generateImagesCheckbox ? generateImagesCheckbox.checked : false;

        setButtonState(generateEditsBtn, 'loading', 'AI analyzing...');
        const progressMsg = generateImages
          ? `AI is analyzing "${msg.frameName}" to generate 5 creative variants with AI images...`
          : `AI is analyzing "${msg.frameName}" to generate 5 creative variants...`;
        showProgress(progressMsg);

        // Call backend to generate edit variants (with image for vision analysis)
        const result = await callGenerateEditsAPI(
          msg.frameName,
          msg.frameWidth,
          msg.frameHeight,
          msg.layers,
          msg.frameImageBase64,
          generateImages
        );

        console.log('[UI] Generated variants:', result.variants.length);
        result.variants.forEach((v, i) => {
          console.log(`  Variant ${i + 1}: ${v.theme} - ${v.instructions.length} instructions`);
          console.log(`    "${v.humanPrompt}"`);
        });

        // Send variants back to plugin to apply
        setButtonState(generateEditsBtn, 'loading', 'Applying edits...');
        showProgress(`Generated ${result.variants.length} variants. Applying edits to canvas...`);

        parent.postMessage({
          pluginMessage: {
            type: 'apply-edit-variants',
            variants: result.variants
          }
        }, '*');

      } catch (error) {
        console.error('[UI] Generate edits failed:', error);
        setButtonState(generateEditsBtn, 'default');
        hideProgress();

        if (error.message.includes('fetch') || error.message.includes('Failed to fetch')) {
          alert('Cannot connect to AI server.\n\nPlease ensure the server is running:\ncd server && npm run dev');
        } else {
          alert('Generate edits failed: ' + error.message);
        }
      }
      return;
    }

    // ============================================
    // Export Data (both regular and AI flow use this)
    // ============================================
    if (msg.type === 'export-data') {
      try {
        // Validate required data
        if (!msg.meta || !msg.layers || !msg.folderName) {
          throw new Error('Missing required export data. Please try again.');
        }

        if (!msg.meta.component || !msg.meta.layers) {
          throw new Error('Invalid metadata structure. Please try again.');
        }

        const frameInfo = msg.totalFrames > 1
          ? ` (${msg.frameIndex + 1}/${msg.totalFrames})`
          : '';

        showProgress(`Processing frame ${msg.frameIndex + 1} of ${msg.totalFrames}...`);

        let reconstructedBlob;
        const exportFormat = msg.format || 'png';

        if (exportFormat === 'svg') {
          // SVG reconstruction
          // Sort layers by z-index
          const sortedLayers = msg.meta.layers
            .filter(layer => layer.visible)
            .sort((a, b) => a.z - b.z);

          // Build SVG content
          let svgContent = `<svg width="${msg.meta.component.width}" height="${msg.meta.component.height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n`;

          for (const layer of sortedLayers) {
            const layerData = msg.layers.find(l => l.filename === createFilename(layer.name, layer.id, 'svg'));
            if (!layerData) continue;

            // Decode base64 SVG
            const svgText = atob(layerData.data);

            // Use export bounds if available
            const useX = layer.exportX !== undefined ? layer.exportX : layer.x;
            const useY = layer.exportY !== undefined ? layer.exportY : layer.y;

            // Wrap in a group with transform for positioning
            svgContent += `  <g transform="translate(${useX}, ${useY})">\n`;
            svgContent += `    ${svgText}\n`;
            svgContent += `  </g>\n`;
          }

          svgContent += '</svg>';

          // Convert SVG to blob
          reconstructedBlob = new Blob([svgContent], { type: 'image/svg+xml' });

        } else {
          // PNG reconstruction
          // Get scale factor from metadata (default to 2 for backwards compatibility)
          const scale = msg.meta.scale || 2;

          // Create canvas at the SCALED resolution to match exported layers
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(msg.meta.component.width * scale);
          canvas.height = Math.round(msg.meta.component.height * scale);
          const ctx = canvas.getContext('2d');

          // Sort layers by z-index
          const sortedLayers = msg.meta.layers
            .filter(layer => layer.visible)
            .sort((a, b) => a.z - b.z);

          // Load and draw all layer images
          const loadPromises = [];
          for (let i = 0; i < sortedLayers.length; i++) {
            const layer = sortedLayers[i];
            const layerData = msg.layers.find(l => l.filename === createFilename(layer.name, layer.id, 'png'));

            if (!layerData) continue;

            const promise = new Promise((resolve, reject) => {
              const img = new Image();
              img.onload = () => {
                // Use export bounds if available (for accurate positioning of effects, strokes, etc.)
                // Otherwise fall back to node bounds
                const useX = layer.exportX !== undefined ? layer.exportX : layer.x;
                const useY = layer.exportY !== undefined ? layer.exportY : layer.y;

                // Both canvas and images are at the same scale
                const layerX = Math.round(useX * scale);
                const layerY = Math.round(useY * scale);

                // Actual image dimensions at the exported scale
                const imgWidth = img.naturalWidth || img.width;
                const imgHeight = img.naturalHeight || img.height;

                // Calculate clipping in scaled space
                const sx = Math.max(0, -layerX);
                const sy = Math.max(0, -layerY);
                const sw = Math.min(imgWidth - sx, canvas.width - Math.max(0, layerX));
                const sh = Math.min(imgHeight - sy, canvas.height - Math.max(0, layerY));

                // Draw position in scaled space
                const dx = Math.max(0, layerX);
                const dy = Math.max(0, layerY);

                if (sw > 0 && sh > 0) {
                  ctx.drawImage(img, sx, sy, sw, sh, dx, dy, sw, sh);
                }
                resolve();
              };
              img.onerror = reject;
              img.src = 'data:image/png;base64,' + layerData.data;
            });

            loadPromises.push(promise);
          }

          // Wait for all images to be drawn
          await Promise.all(loadPromises);

          // Convert canvas to blob
          reconstructedBlob = await new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error('Failed to create image blob'));
              }
            }, 'image/png');
          });
        }

        // Store export data for this frame
        frameExportData.push({
          folderName: msg.folderName,
          meta: msg.meta,
          layers: msg.layers,
          reconstructedBlob,
          format: exportFormat,
          frameIndex: msg.frameIndex,
          totalFrames: msg.totalFrames
        });

        console.log(`[UI] Collected frame ${msg.frameIndex + 1}/${msg.totalFrames}: ${msg.folderName}`);

        // If this is the last frame OR single frame, process immediately
        if (msg.frameIndex + 1 === msg.totalFrames) {
          // Don't process here - wait for 'all-exports-complete' message
          console.log(`[UI] All ${msg.totalFrames} frames collected, waiting for completion signal...`);
        }

      } catch (error) {
        console.error('Error creating ZIP:', error);
        alert('Export failed: ' + error.message);
        setButtonState(exportBtn, 'default');
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
      }
    }

    // ============================================
    // All Exports Complete
    // ============================================
    if (msg.type === 'all-exports-complete') {
      try {
        if (frameExportData.length === 0) {
          throw new Error('No frame data to export');
        }

        showProgress('Creating ZIP file...');

        const zip = new JSZip();
        const totalFrames = frameExportData.length;

        // Determine ZIP filename
        let zipFilename;
        if (totalFrames === 1) {
          // Single frame: use frame name
          zipFilename = `${frameExportData[0].folderName}.zip`;
        } else {
          // Multiple frames: use project name or "figma-export"
          zipFilename = `figma-export-${totalFrames}-frames.zip`;
        }

        // Add each frame as a folder in the ZIP
        for (let i = 0; i < frameExportData.length; i++) {
          const frameData = frameExportData[i];
          const frameInfo = totalFrames > 1 ? ` (${i + 1}/${totalFrames})` : '';

          showProgress(`Adding frame ${i + 1} of ${totalFrames} to ZIP...`);

          // Add meta.json with validation
          const metaWithFormat = { ...frameData.meta, format: frameData.format };
          let metaJson;
          try {
            metaJson = JSON.stringify(metaWithFormat, null, 2);
            if (!metaJson || metaJson === '{}') {
              throw new Error(`Failed to serialize metadata for frame ${i + 1}`);
            }
          } catch (e) {
            throw new Error(`Failed to create metadata file for frame ${i + 1}: ` + e.message);
          }

          zip.file(`${frameData.folderName}/meta.json`, metaJson);

          // Add all layer files (PNG or SVG)
          const layersFolder = zip.folder(`${frameData.folderName}/layers`);
          for (const layer of frameData.layers) {
            layersFolder.file(layer.filename, layer.data, { base64: true });
          }

          // Add reconstructed image with correct extension
          const reconstructedExt = frameData.format === 'svg' ? '.svg' : '.png';

          // Validate reconstructed blob before adding
          if (!frameData.reconstructedBlob) {
            throw new Error(`Failed to create reconstructed image for frame ${i + 1}`);
          }

          zip.file(
            `${frameData.folderName}/${frameData.meta.component.name}_reconstructed${reconstructedExt}`,
            frameData.reconstructedBlob
          );

          console.log(`[UI] Added frame ${i + 1}/${totalFrames} to ZIP: ${frameData.folderName}`);
        }

        // Generate ZIP with explicit options for cross-platform compatibility
        showProgress('Finalizing ZIP file...');
        const blob = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: {
            level: 6
          },
          platform: 'UNIX' // Ensures consistent path separators
        });

        // Validate ZIP blob
        if (!blob || blob.size === 0) {
          throw new Error('Failed to generate ZIP file');
        }

        // Trigger download
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = zipFilename;
        a.click();
        URL.revokeObjectURL(url);

        console.log(`[UI] Downloaded: ${zipFilename} (${totalFrames} frame${totalFrames > 1 ? 's' : ''})`);

        // Clear stored data for next export
        frameExportData = [];

        // Show success state in all buttons (whichever was active)
        setButtonState(exportBtn, 'success');
        setButtonState(aiRenameBtn, 'success');
        hideProgress();

      } catch (error) {
        console.error('Error creating final ZIP:', error);
        alert('Export failed: ' + error.message);
        setButtonState(exportBtn, 'default');
        setButtonState(aiRenameBtn, 'default');
        hideProgress();
        frameExportData = []; // Clear on error
      }
    }

    // ============================================
    // Variants Created (Generate Edits complete)
    // ============================================
    if (msg.type === 'variants-created') {
      setButtonState(generateEditsBtn, 'success');
      hideProgress();
      console.log(`[UI] Created ${msg.variantCount} variants successfully`);
    }

    // ============================================
    // Groups Broken (Break Groups complete)
    // ============================================
    if (msg.type === 'groups-broken') {
      setButtonState(breakGroupsBtn, 'success');
      if (msg.groupCount > 0) {
        showProgress(`Ungrouped ${msg.groupCount} groups into ${msg.layerCount} layers.`);
      } else {
        showProgress('No groups found in selection.');
      }
      console.log(`[UI] Broke ${msg.groupCount} groups into ${msg.layerCount} layers`);

      setTimeout(() => {
        setButtonState(breakGroupsBtn, 'default');
        hideProgress();
      }, 2000);
      return;
    }

    // ============================================
    // Rasterize Complete
    // ============================================
    if (msg.type === 'rasterize-complete') {
      setButtonState(rasterizeBtn, 'success');
      if (msg.count > 0) {
        showProgress(`Rasterized ${msg.count} objects at 4x resolution.`);
      } else {
        showProgress('No objects found to rasterize.');
      }
      console.log(`[UI] Rasterized ${msg.count} objects`);

      setTimeout(() => {
        setButtonState(rasterizeBtn, 'default');
        hideProgress();
      }, 2000);
      return;
    }

    // ============================================
    // Error Handler
    // ============================================
    if (msg.type === 'error') {
      alert(msg.message);
      setButtonState(exportBtn, 'default');
      setButtonState(aiRenameBtn, 'default');
      setButtonState(generateEditsBtn, 'default');
      setButtonState(breakGroupsBtn, 'default');
      setButtonState(rasterizeBtn, 'default');
      hideProgress();
    }
  };

</script>